// Copyright 2021 The contributors of Garcon.
// SPDX-License-Identifier: MIT

package main

import (
	"bufio"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strings"

	log "github.com/lynxai-team/emo"
)

var (
	ignoreFolders = []string{
		// Dependency directories
		"bower_components",
		"jspm_packages",
		"node_modules",
		"target",
		"vendor",
		// Logs
		"logs",
		// Runtime data
		"pids",
		// Directory for instrumented libs generated by jscoverage/JSCover
		"lib-cov",
		// Coverage directory used by tools like istanbul
		"coverage",
		// nyc test coverage
		".nyc_output",
		// Grunt intermediate storage
		".grunt",
		// TypeScript v1 declaration files
		"typings",
		// Cache directories
		".parcel-cache",
		".rollup.cache",
		".sass-cache",
		".webpack.cache",
		// npm build output
		"dist",
		// Build outputs
		"build",
		"out",
		// Temporary files
		"tmp",
		"temp",
		// Essential Python-related entries
		"__pycache__",
		"venv",
	}
	ignoreFiles = []string{
		"npm-debug.log*",
		"yarn-debug.log*",
		"yarn-error.log*",
		// node-waf configuration
		".lock-wscript",
		// Cache directories
		".eslintcache",
		// Optional REPL history
		".node_repl_history",
		// Windows cache file
		"Thumbs.db",
		// Essential Node.js-related entries
		"bun.lock",
		"bun.lockb",
		"package-lock.json",
		"pnpm-lock.yaml",
		"yarn-error.log",
		"yarn.lock",
		// Essential Python-related entries
		"Pipfile.lock",
		"poetry.lock",
		"uv.lock",
		// Essential Rust-related entries
		"Cargo.lock",
		"Cargo.toml.orig",
		// Essential PHP-related entries
		"composer.lock",
		// Essential Ruby-related entries
		"Gemfile.lock",
		// Essential Go-related entries
		"go.sum",
		// Essential Elixir-related entries
		"mix.lock",
		// Essential Haskell-related entries
		"cabal.project.freeze",
		"stack.yaml.lock",
	}
	ignoreSuffixes = []string{
		".log",
		// Runtime data
		".pid.lock",
		".pid",
		".seed",
		// Cache directories
		".cache",
		// Archive files
		".7z",  // 7-zip
		".br",  // brotli
		".bz2", // Bzip2
		".gz",  // Gzip
		".iso",
		".rar",
		".tar",
		".tgz",
		".zip",
		".zst", // Zstandard
		// Editor directories and files
		".bak",
		".swn",
		".swo",
		".swp",
		// Essential Python-related entries
		".pyc",
		".pyd",
		".pyo",
		// Essential Rust-related entries
		".rs.bk",
		// images
		".bmp",          // BMP
		".gif",          // GIF
		".ico",          // ICO
		".jpg", ".jpeg", // JPEG
		".png",          // PNG
		".psd",          // PSD
		".svg",          // SVG
		".webp",         // WEBP
		".tif", ".tiff", // TIFF
		// documents
		".docx", // Microsoft Word
		".epub", // ePub
		".odt",  // OpenDocument Text
		".pdf",  // Portable Document Format
		".pptx", // Microsoft PowerPoint
		".rtf",  // Rich Text Format
		".wpd",  // WordPerfect Document
		".xlsx", // Microsoft Excel
	}
)

// ----------------------------------------------------------------------
// Generation mode
// ----------------------------------------------------------------------

// generateMarkdown walks c.folder and writes a markdown document that
// contains each file as a fenced code block.  The output is streamed directly
// to the destination file (or discarded in dry‑run mode) to keep memory usage low.
func (c *Config) generateMarkdown() error {
	log.Printf("Generating markdown %s from folder %s", c.mdPath, c.folder)

	// If the destination already exists and overwriting is disabled, abort early.
	if !c.overwrite {
		_, err := os.Stat(c.mdPath)
		if err == nil {
			return fmt.Errorf("output file %s already exists (use -overwrite to replace)", c.mdPath)
		}
	}

	var out io.Writer
	if c.dryRun {
		out = io.Discard
	} else {
		f, err := os.Create(c.mdPath)
		if err != nil {
			return fmt.Errorf("create %s: %w", c.mdPath, err)
		}
		defer f.Close()
		out = f
	}
	w := bufio.NewWriter(out)

	// Walk the folder tree in lexical order for deterministic output.
	err := filepath.WalkDir(c.folder, func(path string, d fs.DirEntry, walkErr error) error {
		if walkErr != nil {
			// Skip entries that cannot be accessed but continue the walk.
			return nil
		}
		// -all omitted => skip the ignored files
		if !c.all {
			base := filepath.Base(path)
			if d.IsDir() {
				if slices.Contains(ignoreFolders, base) {
					log.Stopf("SKIP folder %q is ignored, use --all to include it", path)
					return filepath.SkipDir
				}
				return nil
			}
			if slices.Contains(ignoreFiles, base) {
				log.Stopf("SKIP file %q is ignored, use --all to include it", path)
				return nil
			}
			for _, suffix := range ignoreSuffixes {
				if strings.HasSuffix(base, suffix) {
					log.Stopf("SKIP file %q is ignored (ext %s), use --all to include it", path, suffix)
					return nil
				}
			}
		}
		if !c.custom.MatchString(path) {
			log.Stopf("SKIP file %q does not match regex %q", path, c.custom)
			return nil
		}
		isBinary, err := isBinaryFile(path)
		if err != nil {
			log.Stopf("SKIP file %q cannot be accessed err=%s", path, err)
			return nil
		}
		if isBinary {
			log.Stopf("SKIP file %q is binary (first bytes are not UTF8)", path)
			return nil
		}
		// Compute a forward‑slash relative path for markdown.
		rel, err := filepath.Rel(c.folder, path)
		if err != nil {
			log.Stopf("SKIP file %q has a weird path filepath.Rel=%s", path, err)
			return nil // should never happen
		}
		rel = filepath.ToSlash(rel)
		log.Inputf("include file %q", path)
		// Header line with filename.
		_, err = fmt.Fprint(w, genFilenameLine(c.header, rel)+"\n\n")
		if err != nil {
			return err
		}

		// Language identifier based on file extension (empty string if unknown).
		ext := strings.TrimPrefix(filepath.Ext(path), ".")
		_, err = fmt.Fprintf(w, "%s%s\n", c.fence, ext)
		if err != nil {
			return err
		}

		// Stream file contents into the markdown.
		f, err := os.Open(path)
		if err != nil {
			fmt.Fprintf(w, "error os.Open(%s) %v\n", path, err)
			log.Warnf("error os.Open(%s) %v\n", path, err)
			// If we cannot read a file, just skip it.
			return nil
		} else {
			_, copyErr := io.Copy(w, f)
			closeErr := f.Close()
			if copyErr != nil {
				log.Warnf("error os.Copy %q %v\n", path, copyErr)
			}
			if closeErr != nil {
				log.Warnf("error os.Close %q %v\n", path, closeErr)
			}
		}

		// Ensure the fenced block ends with a newline and a blank line afterwards.
		_, err = fmt.Fprintf(w, "%s\n\n", c.fence)
		if err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("walk %s: %w", c.folder, err)
	}
	err = w.Flush()
	if err != nil {
		return fmt.Errorf("flush output: %w", err)
	}
	return nil
}

// isBinaryFile checks returns false if the first 128 bytes are UTF-8.
func isBinaryFile(filePath string) (bool, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return false, err
	}
	defer file.Close()

	reader := bufio.NewReader(file)
	buf := make([]byte, 128)

	for {
		n, err := reader.Read(buf)
		if err != nil {
			if err.Error() != "EOF" {
				return false, err
			}
			break
		}

		isUTF8 := Valid(buf[:n])
		return !isUTF8, nil
	}
	return false, nil // No binary characters found
}

// genFilenameLine generates the header line with filename (or filename regex).
func genFilenameLine(header, filename string) string {
	if header == "" {
		return filename
	}

	idx := strings.LastIndexByte(header, ' ')

	switch idx {
	// header format = "something "
	case len(header) - 1:
		return header + filename

	// header format: "`" or "(" or "something `" or "something ("
	case len(header) - 2:
		ending := header[len(header)-1]
		switch ending {
		case '/':
			return header + filename
		case '\\':
			return header + filename
		case '(':
			ending = ')'
		case '[':
			ending = ']'
		case '{':
			ending = '}'
		}
		return header[:idx+2] + filename + string(ending)

	// header format: '**" or "something **"
	case len(header) - 3:
		ending := header[len(header)-2:]
		switch ending {
		case "**":
			return header + filename + "**"
		}
		return header + filename

	default:
		return header + filename // "## File: path/file.go"
	}
}

// ----------------------------------------------------------------------
// Helper utilities
// ----------------------------------------------------------------------

// extractedFile is used only for the final summary printed after extraction.
type extractedFile struct {
	path string
	size int64
}

// collectResults walks the output directory and returns a slice of extractedFile.
// Errors are returned to the caller for proper handling.
func collectResults(root string) ([]extractedFile, error) {
	var out []extractedFile
	err := filepath.WalkDir(root, func(p string, d fs.DirEntry, walkErr error) error {
		if walkErr != nil {
			// Continue walking despite individual errors.
			return nil
		}
		if d.IsDir() {
			return nil
		}
		info, err := d.Info()
		if err != nil {
			return nil
		}
		rel, _ := filepath.Rel(root, p) // ignore Rel error - path is under root.
		out = append(out, extractedFile{path: rel, size: info.Size()})
		return nil
	})
	return out, err
}

// printSummary displays a colorized list of extracted files.
// The color codes are emitted only when stdout is a terminal.
func printSummary(results []extractedFile) {
	const (
		green = "\x1b[32m"
		reset = "\x1b[0m"
		check = "✓"
	)
	for _, r := range results {
		// Use a narrow no‑break space (U+202F) to keep the size column aligned.
		fmt.Printf("%s%s %s (%d\u202F"+"bytes)%s\n", green, check, r.path, r.size, reset)
	}
}
